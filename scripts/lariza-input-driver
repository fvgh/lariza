#!/bin/sh

#                                  _
#    _____  ____ _ _ __ ___  _ __ | | ___
#   / _ \ \/ / _` | '_ ` _ \| '_ \| |/ _ \
#  |  __/>  < (_| | | | | | | |_) | |  __/
#   \___/_/\_\__,_|_| |_| |_| .__/|_|\___|
#                           |_|
#
# This script is an example. It allows for some basic browsing. It does
# not implement anything magical, though.
#
# You -- the user -- are encouraged to customize this script or write
# your own one.
#
# That being said, we launch a per-user script if it exists. This allows
# distributions to simply install this exemplary file in /usr/bin, while
# users are still able to customize it.

per_user_driver=${XDG_CONFIG_HOME:-~/.config}/lariza/input-driver
if [ -x "$per_user_driver" ]
then
    exec "$per_user_driver" "$@"
fi

execute()
{
    case "$context" in
        inputbox)
            # The variable $context_specific_text contains the text
            # entered by the user. You could inspect it further to
            # implement key word based searching or other features.
            #
            # Note that we redirect stdin here. Child processes must not
            # ever read from our stdin since that is the command pipe.
            lariza-keyword-search "$context_specific_text" </dev/null
            ;;
        handle_context_menu_uri)
            # Do something with the URI in $context_specific_text.
            # Replicating the behaviour of lariza's former "external
            # handler" could be done as follows. Please note that this
            # "external handler" always was a pure user-supplied
            # implementation, which is why we don't provide an example
            # today. It's totally up to you.
            #
            # Note that we redirect stdout here as well, because this is
            # an unrelated child process. It should not be able to
            # answer directly to lariza (nor should it be able to read
            # from the command pipe, so stdin is redirected as well).
            lariza-external-handler -u "$context_specific_text" \
                </dev/null >/dev/null &
            echo nop
            ;;
        hid_button)
            case "$key" in
                2)  [ -n "$hover_uri" ] && echo go_uri_new_window "$hover_uri"  ;;
                8)  echo  go_backward  ;;
                9)  echo  go_forward   ;;
            esac
            ;;
        hid_key)
            home=${LARIZA_HOME_URI:-about:blank}
            case "$key" in
                Escape)  echo  abort_load                 ;;
                F2)      echo  go_backward                ;;
                F3)      echo  go_forward                 ;;
                M-3)     echo  search_backward            ;;
                M-c)     echo  reload_user_certs          ;;
                M-d)     echo  download_manager_open      ;;
                M-D)     echo  download_manager_close     ;;
                M-e)     echo  go_uri_new_window "$home"  ;;
                M-k)     echo  search_initiate            ;;
                M-l)     echo  focus_input_box            ;;
                M-n)     echo  search_forward             ;;
                M-q)     echo  close                      ;;
                M-r)     echo  reload_page                ;;
                M-w)     echo  go_uri "$home"             ;;
                M-x)
                    # Replicating the behaviour of lariza's former
                    # "external handler" could be done as follows:
                    lariza-external-handler -u "$current_uri" \
                        </dev/null >/dev/null &
                    echo nop
                    ;;
            esac
            ;;
        hid_scroll)
            case "$key" in
                M-y)      echo  zoom_increase  ;;
                M-Y)      echo  zoom_decrease  ;;
                M-x|M-X)  echo  zoom_reset     ;;
            esac
            ;;
    esac
}

main_loop()
{
    # lariza spawns this script. There's a pipe between the browser and
    # this script. Commands are sent from the browser to us: They tell
    # us what context we're in (key press, text entered into the input
    # box, and so on). Eventually, the browser sends "execute". We must
    # then evaluate all the variables we've been given and decide what
    # to do. Our stdout is connected to a pipe as well, so that's where
    # we write our response to.
    #
    # For performance reasons, we can and should not exit after
    # "execute" has been received. The browser will continue to send us
    # new events as long as we're still alive.
    while read -r command
    do
        case "$command" in
            context|context_specific_text|current_uri|hover_uri|key)
                read -r "$command"
                ;;
            execute)
                res=$(execute)
                echo "${res:-unknown}"
                unset context context_specific_text current_uri hover_uri key
                ;;
        esac
    done
}

main_loop
